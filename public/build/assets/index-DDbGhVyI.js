import{c as w}from"./createLucideIcon-BqkyE-xM.js";import{r as u,j as m,f as y}from"./app-CLKafMi8.js";/**
 * @license lucide-react v0.475.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const z=[["path",{d:"M20 6 9 17l-5-5",key:"1gmf2c"}]],E=w("Check",z);function M(t,c,{checkForDefaultPrevented:o=!0}={}){return function(n){if(t==null||t(n),o===!1||!n.defaultPrevented)return c==null?void 0:c(n)}}function R(t,c){const o=u.createContext(c),i=s=>{const{children:e,...r}=s,f=u.useMemo(()=>r,Object.values(r));return m.jsx(o.Provider,{value:f,children:e})};i.displayName=t+"Provider";function n(s){const e=u.useContext(o);if(e)return e;if(c!==void 0)return c;throw new Error(`\`${s}\` must be used within \`${t}\``)}return[i,n]}function A(t,c=[]){let o=[];function i(s,e){const r=u.createContext(e),f=o.length;o=[...o,e];const x=d=>{var S;const{scope:a,children:b,...h}=d,v=((S=a==null?void 0:a[t])==null?void 0:S[f])||r,p=u.useMemo(()=>h,Object.values(h));return m.jsx(v.Provider,{value:p,children:b})};x.displayName=s+"Provider";function l(d,a){var v;const b=((v=a==null?void 0:a[t])==null?void 0:v[f])||r,h=u.useContext(b);if(h)return h;if(e!==void 0)return e;throw new Error(`\`${d}\` must be used within \`${s}\``)}return[x,l]}const n=()=>{const s=o.map(e=>u.createContext(e));return function(r){const f=(r==null?void 0:r[t])||s;return u.useMemo(()=>({[`__scope${t}`]:{...r,[t]:f}}),[r,f])}};return n.scopeName=t,[i,P(n,...c)]}function P(...t){const c=t[0];if(t.length===1)return c;const o=()=>{const i=t.map(n=>({useScope:n(),scopeName:n.scopeName}));return function(s){const e=i.reduce((r,{useScope:f,scopeName:x})=>{const d=f(s)[`__scope${x}`];return{...r,...d}},{});return u.useMemo(()=>({[`__scope${c.scopeName}`]:e}),[e])}};return o.scopeName=c.scopeName,o}var C=globalThis!=null&&globalThis.document?u.useLayoutEffect:()=>{},$=y[" useInsertionEffect ".trim().toString()]||C;function O({prop:t,defaultProp:c,onChange:o=()=>{},caller:i}){const[n,s,e]=_({defaultProp:c,onChange:o}),r=t!==void 0,f=r?t:n;{const l=u.useRef(t!==void 0);u.useEffect(()=>{const d=l.current;d!==r&&console.warn(`${i} is changing from ${d?"controlled":"uncontrolled"} to ${r?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),l.current=r},[r,i])}const x=u.useCallback(l=>{var d;if(r){const a=j(l)?l(t):l;a!==t&&((d=e.current)==null||d.call(e,a))}else s(l)},[r,t,s,e]);return[f,x]}function _({defaultProp:t,onChange:c}){const[o,i]=u.useState(t),n=u.useRef(o),s=u.useRef(c);return $(()=>{s.current=c},[c]),u.useEffect(()=>{var e;n.current!==o&&((e=s.current)==null||e.call(s,o),n.current=o)},[o,n]),[o,i,s]}function j(t){return typeof t=="function"}function B(t){const[c,o]=u.useState(void 0);return C(()=>{if(t){o({width:t.offsetWidth,height:t.offsetHeight});const i=new ResizeObserver(n=>{if(!Array.isArray(n)||!n.length)return;const s=n[0];let e,r;if("borderBoxSize"in s){const f=s.borderBoxSize,x=Array.isArray(f)?f[0]:f;e=x.inlineSize,r=x.blockSize}else e=t.offsetWidth,r=t.offsetHeight;o({width:e,height:r})});return i.observe(t,{box:"border-box"}),()=>i.unobserve(t)}else o(void 0)},[t]),c}export{E as C,O as a,A as b,M as c,R as d,B as e,C as u};
